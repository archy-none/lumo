use chrono::Local;
use clap::Parser;
use lumo_core::Compiler;
use sha2::{Digest, Sha256};
use std::{
    env::{current_dir, set_current_dir},
    fs::{File, read_to_string},
    io::Write,
    path::Path,
};

#[derive(Parser)]
#[command(
    name = "Lumo",
    about = "A programming language that will be compiled to WebAssembly "
)]
struct Cli {
    /// Source code file path
    path: String,
    /// Show type inference summary
    #[arg(long = "summary", short = 's')]
    summary: bool,
}

fn main() {
    let cli = Cli::parse();
    let mut compiler = Compiler::new();
    let filename = Path::new(&cli.path);

    let Ok(source) = read_to_string(filename) else {
        eprintln!("Failed to read source file");
        return;
    };
    let original_dir = current_dir().unwrap();
    set_current_dir(Path::new(filename).parent().unwrap()).unwrap();
    let Some(wat_code) = compiler.build(&source) else {
        let error_message = "failed to parse, compile or check type consistency";
        let err = compiler.occurred_error.unwrap_or(error_message.to_owned());
        eprintln!("Error: {err}");
        return;
    };
    if cli.summary {
        println!("# Type Inference Summary");
        println!("Functions:");
        compiler.export_type.extend(compiler.function_type.clone());
        for (name, func) in &compiler.export_type {
            println!(
                " - {name}({}): {}",
                func.arguments
                    .iter()
                    .map(|(name, arg)| {
                        let typ = arg.compress_alias(&compiler).format();
                        format!("{name}: {typ}")
                    })
                    .collect::<Vec<_>>()
                    .join(", "),
                func.returns.compress_alias(&compiler).format()
            );
        }
        println!("Variables:");
        for (name, typ) in &compiler.variable_type {
            println!(" - {name}: {}", typ.compress_alias(&compiler).format());
        }
        println!("Globals:");
        for (name, typ) in &compiler.global_type {
            println!(" - {name}: {}", typ.compress_alias(&compiler).format());
        }
        println!("Aliases:");
        for (name, typ) in &compiler.type_alias {
            println!(" - {name}: {}", typ.format());
        }
        println!("Macros:");
        for (name, (args, _)) in &compiler.macro_code {
            println!(" - {name}({})", args.join(", "));
        }
        let returns = compiler.program_return.compress_alias(&compiler).format();
        println!("Returns: {returns}");
    }

    let wat_code = format!(
        ";; Generated by Lumo compiler on {}\n;; Source Hash: {:x}\n{wat_code}",
        Local::now().format("%Y/%m/%d %H:%M:%S"),
        {
            let mut hasher = Sha256::new();
            hasher.update(source.as_bytes());
            hasher.finalize()
        }
    );

    set_current_dir(original_dir).unwrap();
    let Ok(mut output_file) = File::create(filename.with_extension("wat")) else {
        eprintln!("Failed to create output WAT file");
        return;
    };
    let Ok(_) = output_file.write_all(wat_code.as_bytes()) else {
        eprintln!("Failed to write output in the WAT file");
        return;
    };
    let Ok(binary) = wat::parse_str(wat_code) else {
        eprintln!("Failed to compile WAT file");
        return;
    };
    let Ok(mut output_file) = File::create(filename.with_extension("wasm")) else {
        eprintln!("Failed to create output WASM file");
        return;
    };
    let Ok(_) = output_file.write_all(&binary) else {
        eprintln!("Failed to write generated binary in the WASM file");
        return;
    };
}
